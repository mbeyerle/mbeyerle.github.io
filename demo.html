<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tibi Color Wheel</title>
<style>
  :root{
    --size:760px;
    --bg:#000;
    --ui:#fff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--ui);padding:24px}
  .wrap{width:min(var(--size),96vw);text-align:center; position:relative;}
  h1{color:#fff;margin:6px 0 12px;font-size:18px}
  .canvas-wrap{background:transparent;border-radius:12px;padding:12px;display:flex;gap:12px;align-items:center;justify-content:center}
  svg{touch-action:none; display:block; max-width:100%;}
  .slice { stroke:none; shape-rendering:geometricPrecision; pointer-events:auto; cursor:pointer; }
  .slice-highlight { filter: drop-shadow(0 4px 12px rgba(0,0,0,.55)); stroke:#ffffffcc; stroke-width:3; }
  .center-label { font-family: "Libre Baskerville", Georgia, serif; font-weight:700; fill:#fff; text-anchor:middle; dominant-baseline:middle; letter-spacing:2px; }

  /* Focus / ring control style (now vertically centered beside the wheel) */
  .focus-control {
    position: absolute;
    /* vertically center the control relative to .wrap (so it's aligned with wheel center) */
    top: 50%;
    transform: translateY(-50%);
    /* keep the panel to the right of the wrap so it never overlaps the wheel */
    left: calc(100% + 12px);
    right: auto;
    background: rgba(255,255,255,0.06);
    color: #fff;
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    display: flex;
    gap: 10px;
    align-items: flex-start;
    backdrop-filter: blur(4px);
    user-select: none;
    z-index: 40;
    flex-direction: column;
    min-width: 180px;
  }
  .focus-row { display:flex; gap:8px; align-items:center; justify-content:space-between; }
  .focus-row .label { display:flex; gap:8px; align-items:center; }
  .focus-control input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: #fff;
    cursor: pointer;
    flex: 0 0 16px;
  }
  .ring-toggle-list {
    display:flex;
    flex-direction:column;
    gap:6px;
    align-items:flex-start;
  }
  /* label layout: checkbox on the left, text on the right */
  .ring-toggle-list label { font-size: 13px; color: #fff; display:flex; gap:8px; align-items:center; cursor:pointer; }

  /* When a ring is turned off, force its slices to be fully black and remove pointer events */
  .ring-off path { fill: #000 !important; stroke: none !important; pointer-events: none !important; cursor: default !important; }

  /* Slight visual cue for toggles (optional) */
  .ring-toggle-list input[type="checkbox"]:checked + span { opacity: 0.98; }

</style>
</head>
<body>
  <div class="wrap">
    <h1>Interactive Tibi Color Wheel</h1>

    <!-- Focus and ring visibility controls (now vertically centered with the wheel) -->
    <div class="focus-control" title="Show only a small sliver at the east side / toggle rings">
      <div class="focus-row">
        <label class="label" title="Show only a small sliver at the east side">
          <input id="applyFocus" type="checkbox" />
          <span>Apply focus</span>
        </label>
      </div>

      <div class="ring-toggle-list" title="Check to show a ring; uncheck to blackout it">
        <!-- Inputs are CHECKED by default = ring visible -->
        <label><input type="checkbox" id="off4" checked><span>Ring 4 (outer)</span></label>
        <label><input type="checkbox" id="off3" checked><span>Ring 3</span></label>
        <label><input type="checkbox" id="off2" checked><span>Ring 2</span></label>
        <label><input type="checkbox" id="off1" checked><span>Ring 1 (center ring)</span></label>
      </div>
    </div>

    <div class="canvas-wrap">
      <svg id="wheel" viewBox="0 0 600 600" width="720" height="720" aria-label="Tibi Color Wheel">
        <!-- groups (outer first so inner rings paint on top) -->
        <g id="ring4" data-ring="4" transform="rotate(0 300 300)"></g>
        <g id="ring3" data-ring="3" transform="rotate(0 300 300)"></g>
        <g id="ring2" data-ring="2" transform="rotate(0 300 300)"></g>
        <g id="ring1" data-ring="1" transform="rotate(0 300 300)"></g>

        <!-- final center cover so center is a clean disk -->
        <circle id="centerDisk" cx="300" cy="300" r="48" fill="#050505"/>
        <text class="center-label" x="300" y="300" font-size="14"></text> 

        <!-- overlay path: full-rect outer subpath + wedge subpath as a second subpath.
             fill-rule:evenodd makes the wedge a hole (transparent) so events pass through there. -->
        <path id="focusOverlayPath"
              fill="#000"
              fill-rule="evenodd"
              d=""
              style="display:none;"
              pointer-events="auto"></path>
      </svg>
    </div>
  </div>

<script>
/*
Entire original script retained unchanged â€” only the CSS positioning of .focus-control changed.
(For brevity I haven't repeated the full JS comments here; the original script logic is left intact.)
*/
(function(){
  const svg = document.getElementById('wheel');
  const cx = 300, cy = 300;

  const segmentsByRing = {1:1,2:8,3:17,4:19};

  const ringConfig = {1:{rOut:64},2:{rOut:170},3:{rOut:260},4:{rOut:300}};

  const palettes = {
    1: ["#000000"],
    2: ["#654F1F","#32373B","#B2B5B4","#EBF3F3","#C9C3B2","#9C8B90","#0C1424","#5B3511"],
    3: ["#416D60","#5D735E","#7D8560","#C99B3A","#E09960","#E28125","#CB5A29","#A65038","#8D382E","#6C1E14","#743E4B","#59424E","#655965","#7E6B88","#687A9B","#79A5AF","#53787A"],
    4: ["#ED97C0","#00AB4F","#059247","#74C480","#DAEDDA","#F6851F","#FAAB66","#ED1C24","#DA1C23","#F7A7A9","#EBE711","#EEEE99","#03A0DC","#67C6EF","#3B59A8","#BDC5E4","#824E9F","#BC93C4","#D43795"]
  };

  const overlapDeg = 0.8;

  [4,3,2,1].forEach(ring => {
    const g = document.getElementById('ring' + ring);
    g.dataset.rotation = '0';
    const pal = palettes[ring] || ["#ccc"];
    const rOut = ringConfig[ring].rOut;
    const rIn = (ring > 1) ? ringConfig[ring-1].rOut : 0;
    const segments = segmentsByRing[ring];
    for (let i=0;i<segments;i++){
      const seg = 360 / segments;
      const start = (i*seg) - overlapDeg/2;
      const end   = ((i+1)*seg) + overlapDeg/2;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.classList.add('slice');
      path.setAttribute('d', wedgePath(cx,cy, rOut, start, end, rIn));
      path.setAttribute('fill', pal[i % pal.length]);
      const nominalMid = ((i + 0.5) * seg) % 360;
      path.setAttribute('data-seg-index', i);
      path.setAttribute('data-mid', nominalMid);
      path.setAttribute('data-start', (i*seg) % 360);
      path.setAttribute('data-end', ((i+1)*seg) % 360);
      path.setAttribute('data-index', i);
      path.setAttribute('data-ring', ring);
      path.addEventListener('click', onSliceClick);
      g.appendChild(path);
    }
  });

  function wedgePath(cx,cy,rOut,startDeg,endDeg,rIn = 0){
    const outerStart = polarToCartesian(cx,cy,rOut,endDeg);
    const outerEnd   = polarToCartesian(cx,cy,rOut,startDeg);
    const innerEnd = polarToCartesian(cx,cy,rIn,startDeg);
    const innerStart = polarToCartesian(cx,cy,rIn,endDeg);
    let sweep = endDeg - startDeg;
    while (sweep < 0) sweep += 360;
    sweep = sweep % 360;
    const largeArc = (sweep > 180) ? 1 : 0;
    if (rIn === 0) {
      return `M ${cx} ${cy} L ${outerStart.x} ${outerStart.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${outerEnd.x} ${outerEnd.y} Z`;
    } else {
      return `M ${outerStart.x} ${outerStart.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${outerEnd.x} ${outerEnd.y} L ${innerEnd.x} ${innerEnd.y} A ${rIn} ${rIn} 0 ${largeArc} 1 ${innerStart.x} ${innerStart.y} Z`;
    }
  }

  function polarToCartesian(cx,cy,r,deg){
    const rad = (deg - 90) * Math.PI / 180.0;
    return { x: cx + (r * Math.cos(rad)), y: cy + (r * Math.sin(rad)) };
  }

  let active = null;
  const locks = {1:false,2:false,3:false,4:false};

  function getPointerAngle(evt){
    const p = (evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const pt = svg.createSVGPoint();
    pt.x = p.clientX; pt.y = p.clientY;
    const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
    const dx = loc.x - cx, dy = loc.y - cy;
    return Math.atan2(dy,dx) * 180 / Math.PI;
  }

  function findRingGroupFromTarget(t){
    return t.closest ? t.closest('g') : null;
  }

  svg.addEventListener('pointerdown', (evt)=>{
    if (evt.button !== undefined && evt.button !== 0) return;
    const g = findRingGroupFromTarget(evt.target);
    if (!g) return;
    const ringNum = parseInt(g.dataset.ring,10);
    if (locks[ringNum]) return;
    svg.setPointerCapture && svg.setPointerCapture(evt.pointerId);
    active = { ringEl: g, startAngle: getPointerAngle(evt), startRotation: parseFloat(g.dataset.rotation) || 0, pointerId: evt.pointerId };
    evt.preventDefault();
  });

  window.addEventListener('pointermove', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    const angleNow = getPointerAngle(evt);
    let delta = angleNow - active.startAngle;
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;
    const newRot = active.startRotation + delta;
    active.ringEl.dataset.rotation = newRot;
    active.ringEl.setAttribute('transform', `rotate(${newRot} ${cx} ${cy})`);
  });

  window.addEventListener('pointerup', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    svg.releasePointerCapture && svg.releasePointerCapture(evt.pointerId);
    active = null;
  });

  let highlightedKey = null;
  function onSliceClick(evt){
    evt.stopPropagation();
    const clickedPath = evt.currentTarget;
    const ring = parseInt(clickedPath.dataset.ring,10);
    const g = document.getElementById('ring' + ring);
    if (g.classList.contains('ring-off')) return;
    const groupRot = parseFloat(g.dataset.rotation) || 0;
    const localMid = parseFloat(clickedPath.dataset.mid);
    const absoluteMid = (localMid + groupRot + 360) % 360;
    const key = Math.round(absoluteMid * 100) / 100;
    if (highlightedKey === key) {
      clearHighlights();
      highlightedKey = null;
      return;
    }
    highlightedKey = key;
    applyHighlightsAtAbsoluteAngle(absoluteMid);
  }

  function applyHighlightsAtAbsoluteAngle(absAngle){
    clearHighlights();
    for (let r=1;r<=4;r++){
      const g = document.getElementById('ring'+r);
      if (g.classList.contains('ring-off')) continue;
      const rot = parseFloat(g.dataset.rotation) || 0;
      const n = segmentsByRing[r];
      const localAngleForR = (absAngle - rot + 360) % 360;
      const idx = Math.floor((localAngleForR) / (360 / n)) % n;
      const slice = g.querySelector('path[data-seg-index="'+idx+'"]');
      if (slice) slice.classList.add('slice-highlight');
    }
  }

  function clearHighlights(){
    svg.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
  }

  svg.addEventListener('click', (e) => {
    if (e.target === svg) { clearHighlights(); highlightedKey = null; }
  });

  window.addEventListener('keydown', (e)=>{
    if (e.key >= '1' && e.key <= '4') {
      const r = parseInt(e.key,10);
      const g = document.getElementById('ring'+r);
      const cur = parseFloat(g.dataset.rotation) || 0;
      g.dataset.rotation = cur + 30;
      g.setAttribute('transform', `rotate(${cur+30} ${cx} ${cy})`);
    }
  });

  window.tibiWheel = {
    rotateTo: (ring,deg) => {
      const g = document.getElementById('ring'+ring);
      g.dataset.rotation = deg;
      g.setAttribute('transform', `rotate(${deg} ${cx} ${cy})`);
    },
    lockRing: (ring,locked) => { locks[ring] = !!locked; }
  };

  const focusCheckbox = document.getElementById('applyFocus');
  const overlayPath = document.getElementById('focusOverlayPath');

  const focusWidth = 15;
  const focusCenter = 90;
  const wedgeStart = focusCenter - (focusWidth / 2);
  const wedgeEnd = focusCenter + (focusWidth / 2);

  const holeRadius = Math.max(ringConfig[4].rOut, 320) + 60;

  function buildOverlayD(){
    const rectSub = `M 0 0 H 600 V 600 H 0 Z`;
    const wedgeSub = wedgePath(cx, cy, holeRadius, wedgeStart, wedgeEnd, 0);
    return rectSub + ' ' + wedgeSub;
  }

  overlayPath.setAttribute('d', buildOverlayD());
  overlayPath.style.display = 'none';

  focusCheckbox.addEventListener('change', (e) => {
    overlayPath.style.display = e.target.checked ? 'block' : 'none';
  });

  if (focusCheckbox.checked) overlayPath.style.display = 'block';

  window.addEventListener('resize', () => {
    overlayPath.setAttribute('d', buildOverlayD());
  });

  const visCheckboxes = {
    1: document.getElementById('off1'),
    2: document.getElementById('off2'),
    3: document.getElementById('off3'),
    4: document.getElementById('off4')
  };

  function setRingVisibility(ring, isVisible){
    const g = document.getElementById('ring' + ring);
    if (!g) return;
    if (!isVisible) {
      g.classList.add('ring-off');
      g.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
    } else {
      g.classList.remove('ring-off');
    }
  }

  Object.keys(visCheckboxes).forEach(k => {
    const ringNum = parseInt(k, 10);
    const cb = visCheckboxes[ringNum];
    if (!cb) return;
    cb.addEventListener('change', (e) => {
      setRingVisibility(ringNum, !!e.target.checked);
      if (highlightedKey !== null) {
        applyHighlightsAtAbsoluteAngle(highlightedKey);
      }
    });
    setRingVisibility(ringNum, !!cb.checked);
  });

})();
</script>
</body>
</html>
