<!DOCTYPE html>  
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tibi Color Wheel</title>
<style>
  :root{
    --size:760px;
    --bg:#000;
    --ui:#fff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--ui);padding:24px}
  .wrap{width:min(var(--size),96vw);text-align:center; position:relative;}
  h1{color:#fff;margin:6px 0 12px;font-size:18px}
  .canvas-wrap{background:transparent;border-radius:12px;padding:12px;display:flex;gap:12px;align-items:center;justify-content:center}
  svg{touch-action:none; display:block; max-width:100%;}
  .slice { stroke:none; shape-rendering:geometricPrecision; pointer-events:auto; cursor:pointer; }
  .slice-highlight { filter: drop-shadow(0 4px 12px rgba(0,0,0,.55)); stroke:#ffffffcc; stroke-width:3; }
  .center-label { font-family: "Libre Baskerville", Georgia, serif; font-weight:700; fill:#fff; text-anchor:middle; dominant-baseline:middle; letter-spacing:2px; }

  /* Focus control style (top-right) */
  .focus-control {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.06);
    color: #fff;
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 14px;
    display: flex;
    gap: 8px;
    align-items: center;
    backdrop-filter: blur(4px);
    user-select: none;
    z-index: 40;
  }
  .focus-control input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: #fff;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Interactive Tibi Color Wheel</h1>

    <!-- Top-right focus checkbox -->
    <label class="focus-control" title="Show only a small sliver at the east side">
      <input id="applyFocus" type="checkbox" />
      Apply focus
    </label>

    <div class="canvas-wrap">
      <svg id="wheel" viewBox="0 0 600 600" width="720" height="720" aria-label="Tibi Color Wheel">
        <!-- groups (outer first so inner rings paint on top) -->
        <g id="ring4" data-ring="4" transform="rotate(0 300 300)"></g>
        <g id="ring3" data-ring="3" transform="rotate(0 300 300)"></g>
        <g id="ring2" data-ring="2" transform="rotate(0 300 300)"></g>
        <g id="ring1" data-ring="1" transform="rotate(0 300 300)"></g>

        <!-- final center cover so center is a clean disk -->
        <circle id="centerDisk" cx="300" cy="300" r="48" fill="#050505"/>
        <text class="center-label" x="300" y="300" font-size="14"></text> 
        <!-- Currently no center label of "Tibi" -->

        <!-- overlay path: full-rect outer subpath + wedge subpath as a second subpath.
             fill-rule:evenodd makes the wedge a hole (transparent) so events pass through there. -->
        <path id="focusOverlayPath"
              fill="#000"
              fill-rule="evenodd"
              d=""
              style="display:none;"
              pointer-events="auto"></path>
      </svg>
    </div>
  </div>

<script>
/*
Pie-wedge stacked wheel with focus overlay that allows dragging through the visible wedge.
*/

(function(){
  const svg = document.getElementById('wheel');
  const cx = 300, cy = 300;

  // segments per ring (requested)
  const segmentsByRing = {
    1: 1,
    2: 8,
    3: 17,
    4: 19
  };

  // ring radii
  const ringConfig = {
    1: {rOut: 64},
    2: {rOut: 170},
    3: {rOut: 260},
    4: {rOut: 300}
  };

  // same image-sampled palettes you approved (will wrap if palette shorter than segments)
  const palettes = {
    1: ["#000000"],
    2: ["#654F1F","#32373B","#B2B5B4","#EBF3F3","#C9C3B2","#9C8B90","#0C1424","#5B3511"],
    3: ["#000000","#ffffff","#a64f38","#6c1e14","#743d4b","#655a64","#7e6c89","#68799a","#54787a","#426d60","#7d8661","#c99c3c","#d2b59a","#b08a6a"],
    4: ["#000000","#ffffff","#dc1c24","#ece811","#ecf09b","#67c7ef","#bcc5e4","#824e9f","#d43795","#ee97c0","#059347","#dceed9","#8aa4b6","#3b5f3a","#f0c8a4","#9a6b8f","#c4d9ef","#2b2b2b","#6f6c5f"]
  };

  // angle overlap to prevent seams
  const overlapDeg = 0.8;

  // Build wedges for each ring, outer -> inner
  [4,3,2,1].forEach(ring => {
    const g = document.getElementById('ring' + ring);
    g.dataset.rotation = '0';
    const pal = palettes[ring] || ["#ccc"];
    const rOut = ringConfig[ring].rOut;
    const segments = segmentsByRing[ring];
    for (let i=0;i<segments;i++){
      const seg = 360 / segments;
      const start = (i*seg) - overlapDeg/2;
      const end   = ((i+1)*seg) + overlapDeg/2;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.classList.add('slice');

      // path for wedge (center -> outer arc -> center)
      path.setAttribute('d', wedgePath(cx,cy, rOut, start, end));
      path.setAttribute('fill', pal[i % pal.length]);

      // store segment index and nominal mid-angle (before any group rotation)
      const nominalMid = ((i + 0.5) * seg) % 360;
      path.setAttribute('data-seg-index', i);
      path.setAttribute('data-mid', nominalMid);
      path.setAttribute('data-start', (i*seg) % 360);
      path.setAttribute('data-end', ((i+1)*seg) % 360);
      path.setAttribute('data-index', i); // legacy attr for convenience
      path.setAttribute('data-ring', ring);
      path.addEventListener('click', onSliceClick);
      g.appendChild(path);
    }
  });

  // Build wedge path: center -> outer arc -> center (closed)
  function wedgePath(cx,cy,rOut,startDeg,endDeg){
    const start = polarToCartesian(cx,cy,rOut,endDeg);
    const end   = polarToCartesian(cx,cy,rOut,startDeg);

    let sweep = endDeg - startDeg;
    while (sweep < 0) sweep += 360;
    sweep = sweep % 360;
    const largeArc = (sweep > 180) ? 1 : 0;

    return `M ${cx} ${cy} L ${start.x} ${start.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${end.x} ${end.y} Z`;
  }

  function polarToCartesian(cx,cy,r,deg){
    const rad = (deg - 90) * Math.PI / 180.0;
    return { x: cx + (r * Math.cos(rad)), y: cy + (r * Math.sin(rad)) };
  }

  // Interaction: rotate rings (pointer events)
  let active = null;
  const locks = {1:false,2:false,3:false,4:false};

  function getPointerAngle(evt){
    const p = (evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const pt = svg.createSVGPoint();
    pt.x = p.clientX; pt.y = p.clientY;
    const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
    const dx = loc.x - cx, dy = loc.y - cy;
    return Math.atan2(dy,dx) * 180 / Math.PI;
  }

  function findRingGroupFromTarget(t){
    return t.closest ? t.closest('g') : null;
  }

  svg.addEventListener('pointerdown', (evt)=>{
    if (evt.button !== undefined && evt.button !== 0) return;
    const g = findRingGroupFromTarget(evt.target);
    if (!g) return;
    const ringNum = parseInt(g.dataset.ring,10);
    if (locks[ringNum]) return;
    svg.setPointerCapture && svg.setPointerCapture(evt.pointerId);
    active = { ringEl: g, startAngle: getPointerAngle(evt), startRotation: parseFloat(g.dataset.rotation) || 0, pointerId: evt.pointerId };
    evt.preventDefault();
  });

  window.addEventListener('pointermove', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    const angleNow = getPointerAngle(evt);
    let delta = angleNow - active.startAngle;
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;
    const newRot = active.startRotation + delta;
    active.ringEl.dataset.rotation = newRot;
    active.ringEl.setAttribute('transform', `rotate(${newRot} ${cx} ${cy})`);
  });

  window.addEventListener('pointerup', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    svg.releasePointerCapture && svg.releasePointerCapture(evt.pointerId);
    active = null;
  });

  // highlight across rings on click
  let highlightedKey = null;
  function onSliceClick(evt){
    evt.stopPropagation();

    const clickedPath = evt.currentTarget;
    const ring = parseInt(clickedPath.dataset.ring,10);
    const g = document.getElementById('ring' + ring);
    const groupRot = parseFloat(g.dataset.rotation) || 0;
    const localMid = parseFloat(clickedPath.dataset.mid);
    // absolute mid angle in wheel coordinates (0-360)
    const absoluteMid = (localMid + groupRot + 360) % 360;

    // create a key for toggling: ring:idx:absoluteMidRounded
    const key = Math.round(absoluteMid * 100) / 100;

    if (highlightedKey === key) { // toggle off
      clearHighlights();
      highlightedKey = null;
      return;
    }

    highlightedKey = key;
    applyHighlightsAtAbsoluteAngle(absoluteMid);
  }

  function applyHighlightsAtAbsoluteAngle(absAngle){
    clearHighlights();
    for (let r=1;r<=4;r++){
      const g = document.getElementById('ring'+r);
      const rot = parseFloat(g.dataset.rotation) || 0;
      const n = segmentsByRing[r];
      const localAngleForR = (absAngle - rot + 360) % 360;
      const idx = Math.floor((localAngleForR) / (360 / n)) % n;
      const slice = g.querySelector('path[data-seg-index="'+idx+'"]');
      if (slice) slice.classList.add('slice-highlight');
    }
  }

  function clearHighlights(){
    svg.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
  }

  // click background clears highlight
  svg.addEventListener('click', (e) => {
    if (e.target === svg) { clearHighlights(); highlightedKey = null; }
  });

  // keyboard nudges
  window.addEventListener('keydown', (e)=>{
    if (e.key >= '1' && e.key <= '4') {
      const r = parseInt(e.key,10);
      const g = document.getElementById('ring'+r);
      const cur = parseFloat(g.dataset.rotation) || 0;
      g.dataset.rotation = cur + 30;
      g.setAttribute('transform', `rotate(${cur+30} ${cx} ${cy})`);
    }
  });

  // expose simple API for debugging / external control
  window.tibiWheel = {
    rotateTo: (ring,deg) => {
      const g = document.getElementById('ring'+ring);
      g.dataset.rotation = deg;
      g.setAttribute('transform', `rotate(${deg} ${cx} ${cy})`);
    },
    lockRing: (ring,locked) => { locks[ring] = !!locked; }
  };

  /***** Focus overlay setup using an even-odd path (rectangle minus wedge) *****/
  const focusCheckbox = document.getElementById('applyFocus');
  const overlayPath = document.getElementById('focusOverlayPath');

  // Focus wedge config (15° wide centered at east/right -> 90°)
  const focusWidth = 15; // degrees visible
  const focusCenter = 90; // east is 90° in this coordinate system
  const wedgeStart = focusCenter - (focusWidth / 2);
  const wedgeEnd = focusCenter + (focusWidth / 2);

  // Use a radius slightly larger than the outermost ring to produce a clean wedge hole
  const holeRadius = Math.max(ringConfig[4].rOut, 320) + 60;

  // Build the full-rect outer subpath + the wedge subpath (wedge produced by wedgePath)
  function buildOverlayD(){
    const rectSub = `M 0 0 H 600 V 600 H 0 Z`;
    const wedgeSub = wedgePath(cx, cy, holeRadius, wedgeStart, wedgeEnd);
    return rectSub + ' ' + wedgeSub;
  }

  overlayPath.setAttribute('d', buildOverlayD());
  overlayPath.style.display = 'none'; // initially hidden

  // Toggle overlay visibility — when visible, it intercepts events outside the wedge hole;
  // events inside the hole propagate to underlying wheel elements allowing drag.
  focusCheckbox.addEventListener('change', (e) => {
    overlayPath.style.display = e.target.checked ? 'block' : 'none';
  });

  // If you want the focus to persist on page load based on checkbox state:
  if (focusCheckbox.checked) overlayPath.style.display = 'block';

  // update overlay path on resize (if needed)
  window.addEventListener('resize', () => {
    overlayPath.setAttribute('d', buildOverlayD());
  });

})();
</script>
</body>
</html>
