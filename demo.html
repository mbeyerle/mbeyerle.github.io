<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tibi Color Wheel</title>
<style>
  :root{
    --size:760px;
    --bg:#000;
    --ui:#fff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--ui);padding:24px}
  .wrap{width:min(var(--size),96vw);text-align:center; position:relative;}
  h1{color:#fff;margin:6px 0 12px;font-size:18px}
  .canvas-wrap{background:transparent;border-radius:12px;padding:12px;display:flex;gap:12px;align-items:center;justify-content:center}
  svg{touch-action:none; display:block; max-width:100%;}
  .slice { stroke:none; shape-rendering:geometricPrecision; pointer-events:auto; cursor:pointer; }
  .slice-highlight { filter: drop-shadow(0 4px 12px rgba(0,0,0,.55)); stroke:#ffffffcc; stroke-width:3; }
  .center-label { font-family: "Libre Baskerville", Georgia, serif; font-weight:700; fill:#fff; text-anchor:middle; dominant-baseline:middle; letter-spacing:2px; }

  /* Focus / ring control style (moved to the right of the wrap) */
  .focus-control {
    position: absolute;
    top: 10px;
    left: calc(100% + 12px); /* place the panel well to the right of the wrap so it never overlaps the wheel */
    right: auto;
    background: rgba(255,255,255,0.06);
    color: #fff;
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    display: flex;
    gap: 10px;
    align-items: flex-start;
    backdrop-filter: blur(4px);
    user-select: none;
    z-index: 40;
    flex-direction: column;
    min-width: 180px;
  }
  .focus-row { display:flex; gap:8px; align-items:center; justify-content:space-between; }
  .focus-row .label { display:flex; gap:8px; align-items:center; }
  .focus-control input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: #fff;
    cursor: pointer;
    flex: 0 0 16px;
  }
  .ring-toggle-list {
    display:flex;
    flex-direction:column;
    gap:6px;
    align-items:flex-start;
  }
  /* label layout: checkbox on the left, text on the right */
  .ring-toggle-list label { font-size: 13px; color: #fff; display:flex; gap:8px; align-items:center; cursor:pointer; }

  /* When a ring is turned off, force its slices to be fully black and remove pointer events */
  .ring-off path { fill: #000 !important; stroke: none !important; pointer-events: none !important; cursor: default !important; }

  /* Slight visual cue for toggles (optional) */
  .ring-toggle-list input[type="checkbox"]:checked + span { opacity: 0.98; }

</style>
</head>
<body>
  <div class="wrap">
    <h1>Interactive Tibi Color Wheel</h1>

    <!-- Top-right focus and ring visibility controls (now placed to the right of .wrap) -->
    <div class="focus-control" title="Show only a small sliver at the east side / toggle rings">
      <div class="focus-row">
        <label class="label" title="Show only a small sliver at the east side">
          <input id="applyFocus" type="checkbox" />
          <span>Apply focus</span>
        </label>
      </div>

      <div class="ring-toggle-list" title="Check to show a ring; uncheck to blackout it">
        <!-- Inputs are CHECKED by default = ring visible -->
        <label><input type="checkbox" id="off4" checked><span>Ring 4 (outer)</span></label>
        <label><input type="checkbox" id="off3" checked><span>Ring 3</span></label>
        <label><input type="checkbox" id="off2" checked><span>Ring 2</span></label>
        <label><input type="checkbox" id="off1" checked><span>Ring 1 (center ring)</span></label>
      </div>
    </div>

    <div class="canvas-wrap">
      <svg id="wheel" viewBox="0 0 600 600" width="720" height="720" aria-label="Tibi Color Wheel">
        <!-- A parent group that we will scale/translate to zoom the wheel during focus -->
        <g id="wheelGroup">
          <!-- groups (outer first so inner rings paint on top) -->
          <g id="ring4" data-ring="4" transform="rotate(0 300 300)"></g>
          <g id="ring3" data-ring="3" transform="rotate(0 300 300)"></g>
          <g id="ring2" data-ring="2" transform="rotate(0 300 300)"></g>
          <g id="ring1" data-ring="1" transform="rotate(0 300 300)"></g>

          <!-- final center cover so center is a clean disk -->
          <circle id="centerDisk" cx="300" cy="300" r="48" fill="#050505"/>
          <text class="center-label" x="300" y="300" font-size="14"></text> 
        </g>

        <!-- overlay path: full-rect outer subpath + wedge subpath as a second subpath.
             fill-rule:evenodd makes the wedge a hole (transparent) so events pass through there. -->
        <path id="focusOverlayPath"
              fill="#000"
              fill-rule="evenodd"
              d=""
              style="display:none;"
              pointer-events="auto"></path>
      </svg>
    </div>
  </div>

<script>
/*
Pie-wedge stacked wheel with focus overlay that allows dragging through the visible wedge.
Check boxes: CHECKED = ring visible; UNCHECKED = ring turns black and is non-interactive.

Focus zoom behavior:
 - scaleFactor is applied to wheelGroup (scale around center).
 - overlay hole radius is multiplied by the same factor so the visible wedge reveals the scaled detail.
*/

(function(){
  const svg = document.getElementById('wheel');
  const wheelGroup = document.getElementById('wheelGroup');
  const cx = 300, cy = 300;

  // segments per ring (requested)
  const segmentsByRing = {
    1: 1,
    2: 8,
    3: 17,
    4: 19
  };

  // ring radii (outer radii)
  const ringConfig = {
    1: {rOut: 64},
    2: {rOut: 170},
    3: {rOut: 260},
    4: {rOut: 300}
  };

  // same image-sampled palettes you approved (will wrap if palette shorter than segments)
  const palettes = {
    1: ["#000000"],
    2: ["#654F1F","#32373B","#B2B5B4","#EBF3F3","#C9C3B2","#9C8B90","#0C1424","#5B3511"],
    3: ["#416D60","#5D735E","#7D8560","#C99B3A","#E09960","#E28125","#CB5A29","#A65038","#8D382E","#6C1E14","#743E4B","#59424E","#655965","#7E6B88","#687A9B","#79A5AF","#53787A"],
    4: ["#ED97C0","#00AB4F","#059247","#74C480","#DAEDDA","#F6851F","#FAAB66","#ED1C24","#DA1C23","#F7A7A9","#EBE711","#EEEE99","#03A0DC","#67C6EF","#3B59A8","#BDC5E4","#824E9F","#BC93C4","#D43795"]
  };

  // angle overlap to prevent seams
  const overlapDeg = 0.8;

  // Build wedges for each ring, outer -> inner (annular)
  [4,3,2,1].forEach(ring => {
    const g = document.getElementById('ring' + ring);
    g.dataset.rotation = '0';
    const pal = palettes[ring] || ["#ccc"];
    const rOut = ringConfig[ring].rOut;
    // inner radius is previous ring's outer radius (so wedges are annular)
    const rIn = (ring > 1) ? ringConfig[ring-1].rOut : 0;
    const segments = segmentsByRing[ring];
    for (let i=0;i<segments;i++){
      const seg = 360 / segments;
      const start = (i*seg) - overlapDeg/2;
      const end   = ((i+1)*seg) + overlapDeg/2;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.classList.add('slice');

      // path for annular wedge (inner radius rIn -> outer arc -> inner arc back)
      path.setAttribute('d', wedgePath(cx,cy, rOut, start, end, rIn));
      path.setAttribute('fill', pal[i % pal.length]);

      // store segment index and nominal mid-angle (before any group rotation)
      const nominalMid = ((i + 0.5) * seg) % 360;
      path.setAttribute('data-seg-index', i);
      path.setAttribute('data-mid', nominalMid);
      path.setAttribute('data-start', (i*seg) % 360);
      path.setAttribute('data-end', ((i+1)*seg) % 360);
      path.setAttribute('data-index', i); // legacy attr for convenience
      path.setAttribute('data-ring', ring);
      path.addEventListener('click', onSliceClick);
      g.appendChild(path);
    }
  });

  // Build annular wedge path: outer arc then inner arc back.
  function wedgePath(cx,cy,rOut,startDeg,endDeg,rIn = 0){
    const outerStart = polarToCartesian(cx,cy,rOut,endDeg);
    const outerEnd   = polarToCartesian(cx,cy,rOut,startDeg);

    const innerEnd = polarToCartesian(cx,cy,rIn,startDeg);
    const innerStart = polarToCartesian(cx,cy,rIn,endDeg);

    let sweep = endDeg - startDeg;
    while (sweep < 0) sweep += 360;
    sweep = sweep % 360;
    const largeArc = (sweep > 180) ? 1 : 0;

    if (rIn === 0) {
      return `M ${cx} ${cy} L ${outerStart.x} ${outerStart.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${outerEnd.x} ${outerEnd.y} Z`;
    } else {
      // note inner arc uses opposite sweep flag so the ring sector closes properly
      return `M ${outerStart.x} ${outerStart.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${outerEnd.x} ${outerEnd.y} L ${innerEnd.x} ${innerEnd.y} A ${rIn} ${rIn} 0 ${largeArc} 1 ${innerStart.x} ${innerStart.y} Z`;
    }
  }

  function polarToCartesian(cx,cy,r,deg){
    const rad = (deg - 90) * Math.PI / 180.0;
    return { x: cx + (r * Math.cos(rad)), y: cy + (r * Math.sin(rad)) };
  }

  // Interaction: rotate rings (pointer events)
  let active = null;
  const locks = {1:false,2:false,3:false,4:false};

  function getPointerAngle(evt){
    const p = (evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const pt = svg.createSVGPoint();
    pt.x = p.clientX; pt.y = p.clientY;
    const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
    const dx = loc.x - cx, dy = loc.y - cy;
    return Math.atan2(dy,dx) * 180 / Math.PI;
  }

  function findRingGroupFromTarget(t){
    return t.closest ? t.closest('g') : null;
  }

  svg.addEventListener('pointerdown', (evt)=>{
    if (evt.button !== undefined && evt.button !== 0) return;
    const g = findRingGroupFromTarget(evt.target);
    if (!g) return;
    const ringNum = parseInt(g.dataset.ring,10);
    if (locks[ringNum]) return;
    svg.setPointerCapture && svg.setPointerCapture(evt.pointerId);
    active = { ringEl: g, startAngle: getPointerAngle(evt), startRotation: parseFloat(g.dataset.rotation) || 0, pointerId: evt.pointerId };
    evt.preventDefault();
  });

  window.addEventListener('pointermove', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    const angleNow = getPointerAngle(evt);
    let delta = angleNow - active.startAngle;
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;
    const newRot = active.startRotation + delta;
    active.ringEl.dataset.rotation = newRot;
    // preserve the ring's local rotate transform while parent wheelGroup may also have transforms
    active.ringEl.setAttribute('transform', `rotate(${newRot} ${cx} ${cy})`);
  });

  window.addEventListener('pointerup', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    svg.releasePointerCapture && svg.releasePointerCapture(evt.pointerId);
    active = null;
  });

  // highlight across rings on click
  let highlightedKey = null;
  function onSliceClick(evt){
    evt.stopPropagation();

    const clickedPath = evt.currentTarget;
    const ring = parseInt(clickedPath.dataset.ring,10);
    const g = document.getElementById('ring' + ring);

    if (g.classList.contains('ring-off')) return;

    const groupRot = parseFloat(g.dataset.rotation) || 0;
    const localMid = parseFloat(clickedPath.dataset.mid);
    const absoluteMid = (localMid + groupRot + 360) % 360;

    const key = Math.round(absoluteMid * 100) / 100;

    if (highlightedKey === key) {
      clearHighlights();
      highlightedKey = null;
      return;
    }

    highlightedKey = key;
    applyHighlightsAtAbsoluteAngle(absoluteMid);
  }

  function applyHighlightsAtAbsoluteAngle(absAngle){
    clearHighlights();
    for (let r=1;r<=4;r++){
      const g = document.getElementById('ring'+r);
      if (g.classList.contains('ring-off')) continue;
      const rot = parseFloat(g.dataset.rotation) || 0;
      const n = segmentsByRing[r];
      const localAngleForR = (absAngle - rot + 360) % 360;
      const idx = Math.floor((localAngleForR) / (360 / n)) % n;
      const slice = g.querySelector('path[data-seg-index="'+idx+'"]');
      if (slice) slice.classList.add('slice-highlight');
    }
  }

  function clearHighlights(){
    svg.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
  }

  // click background clears highlight
  svg.addEventListener('click', (e) => {
    if (e.target === svg) { clearHighlights(); highlightedKey = null; }
  });

  // keyboard nudges
  window.addEventListener('keydown', (e)=>{
    if (e.key >= '1' && e.key <= '4') {
      const r = parseInt(e.key,10);
      const g = document.getElementById('ring'+r);
      const cur = parseFloat(g.dataset.rotation) || 0;
      g.dataset.rotation = cur + 30;
      g.setAttribute('transform', `rotate(${cur+30} ${cx} ${cy})`);
    }
  });

  // expose simple API for debugging / external control
  window.tibiWheel = {
    rotateTo: (ring,deg) => {
      const g = document.getElementById('ring'+ring);
      g.dataset.rotation = deg;
      g.setAttribute('transform', `rotate(${deg} ${cx} ${cy})`);
    },
    lockRing: (ring,locked) => { locks[ring] = !!locked; }
  };

  /***** Focus overlay setup using an even-odd path (rectangle minus wedge) *****/
  const focusCheckbox = document.getElementById('applyFocus');
  const overlayPath = document.getElementById('focusOverlayPath');

  // Focus wedge config (15° wide centered at east/right -> 90°)
  const focusWidth = 15; // degrees visible
  const focusCenter = 90; // east is 90° in this coordinate system
  const wedgeStart = focusCenter - (focusWidth / 2);
  const wedgeEnd = focusCenter + (focusWidth / 2);

  // base hole radius (used at scale=1)
  const baseHoleRadius = Math.max(ringConfig[4].rOut, 320) + 60;

  // initial scale factor (1 = normal). Adjust this to taste.
  const focusScale = 2.2;

  // Build the full-rect outer subpath + the wedge subpath (wedge produced by wedgePath)
  function buildOverlayD(scale = 1){
    const rectSub = `M 0 0 H 600 V 600 H 0 Z`;
    const holeR = baseHoleRadius * scale;
    // wedgeSub uses inner radius 0 so it's a wedge-shaped hole that will let events pass
    const wedgeSub = wedgePath(cx, cy, holeR, wedgeStart, wedgeEnd, 0);
    return rectSub + ' ' + wedgeSub;
  }

  // function to set wheelGroup transform to scale around center
  function setWheelScale(scale){
    if (scale === 1) {
      wheelGroup.setAttribute('transform', `translate(0 0)`); // no transform on parent
    } else {
      // translate center -> scale -> translate back
      wheelGroup.setAttribute('transform', `translate(${cx} ${cy}) scale(${scale}) translate(${-cx} ${-cy})`);
    }
  }

  // Toggle overlay visibility & zoom — when visible, it intercepts events outside the wedge hole;
  // events inside the hole propagate to underlying wheel elements allowing drag.
  focusCheckbox.addEventListener('change', (e) => {
    const enabled = !!e.target.checked;
    if (enabled) {
      setWheelScale(focusScale);
      overlayPath.setAttribute('d', buildOverlayD(focusScale));
      overlayPath.style.display = 'block';
    } else {
      setWheelScale(1);
      overlayPath.setAttribute('d', buildOverlayD(1));
      overlayPath.style.display = 'none';
    }
  });

  // initialize overlay & wheel state
  overlayPath.setAttribute('d', buildOverlayD(1));
  overlayPath.style.display = 'none';
  if (focusCheckbox.checked) {
    setWheelScale(focusScale);
    overlayPath.setAttribute('d', buildOverlayD(focusScale));
    overlayPath.style.display = 'block';
  }

  window.addEventListener('resize', () => {
    const scale = focusCheckbox.checked ? focusScale : 1;
    overlayPath.setAttribute('d', buildOverlayD(scale));
    // ensure wheelGroup transform remains correct after any layout changes
    setWheelScale(scale);
  });

  /***** NEW: Visibility checkbox wiring (checked = visible) *****/
  const visCheckboxes = {
    1: document.getElementById('off1'),
    2: document.getElementById('off2'),
    3: document.getElementById('off3'),
    4: document.getElementById('off4')
  };

  function setRingVisibility(ring, isVisible){
    const g = document.getElementById('ring' + ring);
    if (!g) return;
    if (!isVisible) {
      g.classList.add('ring-off');
      // remove any highlights on that ring
      g.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
    } else {
      g.classList.remove('ring-off');
    }
  }

  // Initialize listeners & states
  Object.keys(visCheckboxes).forEach(k => {
    const ringNum = parseInt(k, 10);
    const cb = visCheckboxes[ringNum];
    if (!cb) return;
    // checked = visible; unchecked = blacked-out
    cb.addEventListener('change', (e) => {
      setRingVisibility(ringNum, !!e.target.checked);
      // if highlights exist, recompute so they don't highlight invisible rings
      if (highlightedKey !== null) {
        applyHighlightsAtAbsoluteAngle(highlightedKey);
      }
    });
    // initialize from current state (inputs are checked in markup so rings show by default)
    setRingVisibility(ringNum, !!cb.checked);
  });

})();
</script>
</body>
</html>
