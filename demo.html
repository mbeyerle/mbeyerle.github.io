<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tibi Color Wheel</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: black;
    }
    canvas {
      background: black;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="wheel" width="800" height="800"></canvas>

  <script>
    const canvas = document.getElementById("wheel");
    const ctx = canvas.getContext("2d");
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    // Define Tibi color rings from your reference image
    // (sampled approximate hex codes â€” we can refine if needed)
    const rings = [
      { // RING 1 (center, 6 sectors)
        radius: 100,
        colors: ["#1b1b1b","#6f6368","#b8ada1","#e7ebea","#c7c7c5","#57443b"]
      },
      { // RING 2 (6 sectors)
        radius: 160,
        colors: ["#111823","#432e1a","#50524e","#5f5e5c","#784539","#8d3123"]
      },
      { // RING 3 (10 sectors)
        radius: 230,
        colors: ["#1d2c41","#5b4a6d","#688a95","#38594e","#556b4e",
                 "#8f7842","#c88d4e","#e2913f","#cf6443","#8f4747"]
      },
      { // RING 4 (16 sectors)
        radius: 300,
        colors: ["#44558c","#6f7faa","#97b0c0","#91729a","#b38ab7",
                 "#db83aa","#f09db2","#f7d577","#f8f140","#d8a628",
                 "#ff3300","#ff6f40","#ff964f","#98e7aa","#42b260","#198f47"]
      }
    ];

    // Track rotation per ring
    const rotations = rings.map(() => 0);

    function drawWheel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      rings.forEach((ring, i) => {
        const n = ring.colors.length;
        const angleStep = (2 * Math.PI) / n;
        const innerRadius = i === 0 ? 0 : rings[i - 1].radius;
        const outerRadius = ring.radius;

        for (let j = 0; j < n; j++) {
          const startAngle = rotations[i] + j * angleStep;
          const endAngle = startAngle + angleStep;

          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, outerRadius, startAngle, endAngle);
          ctx.closePath();
          ctx.fillStyle = ring.colors[j];
          ctx.fill();
        }
      });

      // Center label
      ctx.fillStyle = "white";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Tibi", cx, cy + 6);
    }

    drawWheel();

    // Dragging logic
    let isDragging = false;
    let activeRing = null;
    let lastAngle = 0;

    function getAngle(x, y) {
      return Math.atan2(y - cy, x - cx);
    }

    canvas.addEventListener("mousedown", e => {
      const dx = e.offsetX - cx;
      const dy = e.offsetY - cy;
      const r = Math.sqrt(dx * dx + dy * dy);

      activeRing = rings.findIndex(ring => r <= ring.radius && r > (rings[rings.indexOf(ring)-1]?.radius || 0));
      if (activeRing !== -1) {
        isDragging = true;
        lastAngle = getAngle(e.offsetX, e.offsetY);
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (!isDragging) return;
      const angle = getAngle(e.offsetX, e.offsetY);
      const delta = angle - lastAngle;
      rotations[activeRing] += delta;
      lastAngle = angle;
      drawWheel();
    });

    canvas.addEventListener("mouseup", () => isDragging = false);
    canvas.addEventListener("mouseleave", () => isDragging = false);
  </script>
</body>
</html>
