<!DOCTYPE html>  
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tibi Color Wheel — Pie-slice stacked (no gaps)</title>
<style>
  :root{
    --size:760px;
    --bg:#000;
    --ui:#fff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--ui);padding:24px}
  .wrap{width:min(var(--size),96vw);text-align:center;}
  h1{color:#fff;margin:6px 0 12px;font-size:18px}
  .canvas-wrap{background:transparent;border-radius:12px;padding:12px;display:flex;gap:12px;align-items:center;justify-content:center}
  svg{touch-action:none; display:block; max-width:100%;}
  .slice { stroke:none; shape-rendering:geometricPrecision; pointer-events:auto; cursor:pointer; }
  .slice-highlight { filter: drop-shadow(0 4px 12px rgba(0,0,0,.55)); stroke:#ffffffcc; stroke-width:3; }
  .center-label { font-family: "Libre Baskerville", Georgia, serif; font-weight:700; fill:#fff; text-anchor:middle; dominant-baseline:middle; letter-spacing:2px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Tibi Color Wheel — Pie-slice stacked (no gaps)</h1>
    <div class="canvas-wrap">
      <svg id="wheel" viewBox="0 0 600 600" width="720" height="720" aria-label="Tibi Color Wheel">
        <!-- groups (outer first so inner rings paint on top) -->
        <g id="ring4" data-ring="4" transform="rotate(0 300 300)"></g>
        <g id="ring3" data-ring="3" transform="rotate(0 300 300)"></g>
        <g id="ring2" data-ring="2" transform="rotate(0 300 300)"></g>
        <g id="ring1" data-ring="1" transform="rotate(0 300 300)"></g>

        <!-- final center cover so center is a clean disk -->
        <circle id="centerDisk" cx="300" cy="300" r="48" fill="#050505"/>
        <text class="center-label" x="300" y="300" font-size="22">T i b i</text>
      </svg>
    </div>
  </div>

<script>
/*
Pie-wedge stacked wheel:
- Each slice for a ring is drawn as a full wedge (center -> outerRadius arc -> center)
- Rings are drawn outer -> inner so inner rings sit on top
- Small overlapDeg applied to slices to mitigate anti-alias seams
- Drag groups (rings) to rotate independently; click slice to highlight across rings
- Each ring now has its own segment count. Clicking maps the angular position to the
  corresponding slice in every ring (works with rotations).
*/

(function(){
  const svg = document.getElementById('wheel');
  const cx = 300, cy = 300;

  // segments per ring (requested)
  const segmentsByRing = {
    1: 1,
    2: 8,
    3: 17,
    4: 19
  };

  // ring radii
  const ringConfig = {
    1: {rOut: 60},
    2: {rOut: 140},
    3: {rOut: 240},
    4: {rOut: 300}
  };

  // same image-sampled palettes you approved (will wrap if palette shorter than segments)
  const palettes = {
    1: ["#000000"],
    2: ["#767b7b","#b3b5b4","#ebf4f3","#dddfd6","#c9c2b2","#9c8b90","#59535d","#0c1524","#5b3512","#604319"],
    3: ["#e28d40","#cb5b2a","#a64f38","#6c1e14","#743d4b","#655a64","#7e6c89","#68799a","#54787a","#426d60","#7d8661","#c99c3c","#d2b59a","#b08a6a"],
    4: ["#f6851e","#ed1d26","#dc1c24","#ece811","#ecf09b","#67c7ef","#bcc5e4","#824e9f","#d43795","#ee97c0","#059347","#dceed9","#8aa4b6","#3b5f3a","#f0c8a4","#9a6b8f","#c4d9ef","#2b2b2b","#6f6c5f"]
  };

  // angle overlap to prevent seams
  const overlapDeg = 0.8;

  // Build wedges for each ring, outer -> inner
  [4,3,2,1].forEach(ring => {
    const g = document.getElementById('ring' + ring);
    g.dataset.rotation = '0';
    const pal = palettes[ring] || ["#ccc"];
    const rOut = ringConfig[ring].rOut;
    const segments = segmentsByRing[ring];
    for (let i=0;i<segments;i++){
      const seg = 360 / segments;
      const start = (i*seg) - overlapDeg/2;
      const end   = ((i+1)*seg) + overlapDeg/2;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.classList.add('slice');

      // path for wedge (center -> outer arc -> center)
      path.setAttribute('d', wedgePath(cx,cy, rOut, start, end));
      path.setAttribute('fill', pal[i % pal.length]);

      // store segment index and nominal mid-angle (before any group rotation)
      const nominalMid = ((i + 0.5) * seg) % 360;
      path.setAttribute('data-seg-index', i);
      path.setAttribute('data-mid', nominalMid);
      path.setAttribute('data-start', (i*seg) % 360);
      path.setAttribute('data-end', ((i+1)*seg) % 360);
      path.setAttribute('data-index', i); // legacy attr for convenience
      path.setAttribute('data-ring', ring);
      path.addEventListener('click', onSliceClick);
      g.appendChild(path);
    }
  });

  // Build wedge path: center -> outer arc -> center (closed)
  function wedgePath(cx,cy,rOut,startDeg,endDeg){
    const start = polarToCartesian(cx,cy,rOut,endDeg);
    const end   = polarToCartesian(cx,cy,rOut,startDeg);

    let sweep = endDeg - startDeg;
    while (sweep < 0) sweep += 360;
    sweep = sweep % 360;
    const largeArc = (sweep > 180) ? 1 : 0;

    return `M ${cx} ${cy} L ${start.x} ${start.y} A ${rOut} ${rOut} 0 ${largeArc} 0 ${end.x} ${end.y} Z`;
  }

  function polarToCartesian(cx,cy,r,deg){
    const rad = (deg - 90) * Math.PI / 180.0;
    return { x: cx + (r * Math.cos(rad)), y: cy + (r * Math.sin(rad)) };
  }

  // Interaction: rotate rings (pointer events)
  let active = null;
  const locks = {1:false,2:false,3:false,4:false};

  function getPointerAngle(evt){
    const p = (evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const pt = svg.createSVGPoint();
    pt.x = p.clientX; pt.y = p.clientY;
    const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
    const dx = loc.x - cx, dy = loc.y - cy;
    return Math.atan2(dy,dx) * 180 / Math.PI;
  }

  function findRingGroupFromTarget(t){
    return t.closest ? t.closest('g') : null;
  }

  svg.addEventListener('pointerdown', (evt)=>{
    if (evt.button !== undefined && evt.button !== 0) return;
    const g = findRingGroupFromTarget(evt.target);
    if (!g) return;
    const ringNum = parseInt(g.dataset.ring,10);
    if (locks[ringNum]) return;
    svg.setPointerCapture && svg.setPointerCapture(evt.pointerId);
    active = { ringEl: g, startAngle: getPointerAngle(evt), startRotation: parseFloat(g.dataset.rotation) || 0, pointerId: evt.pointerId };
    evt.preventDefault();
  });

  window.addEventListener('pointermove', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    const angleNow = getPointerAngle(evt);
    let delta = angleNow - active.startAngle;
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;
    const newRot = active.startRotation + delta;
    active.ringEl.dataset.rotation = newRot;
    active.ringEl.setAttribute('transform', `rotate(${newRot} ${cx} ${cy})`);
  });

  window.addEventListener('pointerup', (evt)=>{
    if (!active || active.pointerId !== evt.pointerId) return;
    svg.releasePointerCapture && svg.releasePointerCapture(evt.pointerId);
    active = null;
  });

  // highlight across rings on click
  let highlightedKey = null;
  function onSliceClick(evt){
    evt.stopPropagation();

    const clickedPath = evt.currentTarget;
    const ring = parseInt(clickedPath.dataset.ring,10);
    const g = document.getElementById('ring' + ring);
    const groupRot = parseFloat(g.dataset.rotation) || 0;
    const localMid = parseFloat(clickedPath.dataset.mid);
    // absolute mid angle in wheel coordinates (0-360)
    const absoluteMid = (localMid + groupRot + 360) % 360;

    // create a key for toggling: ring:idx:absoluteMidRounded
    const key = Math.round(absoluteMid * 100) / 100;

    if (highlightedKey === key) { // toggle off
      clearHighlights();
      highlightedKey = null;
      return;
    }

    highlightedKey = key;
    applyHighlightsAtAbsoluteAngle(absoluteMid);
  }

  function applyHighlightsAtAbsoluteAngle(absAngle){
    clearHighlights();
    for (let r=1;r<=4;r++){
      const g = document.getElementById('ring'+r);
      const rot = parseFloat(g.dataset.rotation) || 0;
      const n = segmentsByRing[r];
      const localAngleForR = (absAngle - rot + 360) % 360;
      const idx = Math.floor((localAngleForR) / (360 / n)) % n;
      const slice = g.querySelector('path[data-seg-index="'+idx+'"]');
      if (slice) slice.classList.add('slice-highlight');
    }
  }

  function clearHighlights(){
    svg.querySelectorAll('.slice-highlight').forEach(el => el.classList.remove('slice-highlight'));
  }

  // click background clears highlight
  svg.addEventListener('click', (e) => {
    if (e.target === svg) { clearHighlights(); highlightedKey = null; }
  });

  // keyboard nudges
  window.addEventListener('keydown', (e)=>{
    if (e.key >= '1' && e.key <= '4') {
      const r = parseInt(e.key,10);
      const g = document.getElementById('ring'+r);
      const cur = parseFloat(g.dataset.rotation) || 0;
      g.dataset.rotation = cur + 30;
      g.setAttribute('transform', `rotate(${cur+30} ${cx} ${cy})`);
    }
  });

  // expose simple API for debugging / external control
  window.tibiWheel = {
    rotateTo: (ring,deg) => {
      const g = document.getElementById('ring'+ring);
      g.dataset.rotation = deg;
      g.setAttribute('transform', `rotate(${deg} ${cx} ${cy})`);
    },
    lockRing: (ring,locked) => { locks[ring] = !!locked; }
  };

})();
</script>
</body>
</html>
